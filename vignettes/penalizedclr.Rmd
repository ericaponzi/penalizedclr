---
title: "Vignette for penalizedclr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{penalizedclr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The R package "penalizedclr" provides an implementation of the penalized logistic regression model for matched case-control studies. It allows for different penalties in different blocks of covariates, and it is therefore particularly useful in the presence of multi-source omics data. Both L1 and L2 penalties are implemented. 
Additionally, the package performs stability selection for variable selection in the penalized conditional regression model. 


## Installation

You can install the released version of penalizedclr from [CRAN](https://CRAN.R-project.org) with:


```{r eval = FALSE}
install.packages("penalizedclr")
```


And the development version from [GitHub](https://github.com/) with:

```{r eval = FALSE}
library(devtools)
install_github("veradjordjilovic/penalizedclr")
```

Load the package with: 

```{r setup}
library(penalizedclr)
```

## Examples

In this section we will provide examples of how to fit a penalized conditional regression model with source-specific penalty parameters and perform variable selection with penalizedclr. Different choices will be explored for the penalty (L1, or elastic-net via $\alpha$) and for the penalty parameters $\lambda$. We will show how to include information about the different blocks of data and to specify source-specific penalties. 

Initial settings and libraries to be loaded:

```{r message=FALSE, warning=FALSE}
set.seed(123)
require(tidyverse)
```

### Data simulation

We simulate a simple multi-source data set, with two groups of covariates. Each case is matched to one control, and the probability of case vs control in each stratum (case-control pair) is simulated from the linear predictor. An intercept is simulated for each stratum.

```{r}
# two groups of predictors
p <- c(80, 20)

# percent of non-null variables
p_nz <- c(0.2, 0.8)
m_nz <- round(p*p_nz, 0)

# number of different strata (typically case-control pairs)
K <- 125

# number of cases and controls in each stratum
n_cases <- 1
n_ctrl <- 1


# covariates
X = cbind(matrix(rnorm(p[1] * K * (n_cases + n_ctrl), 0, 1), ncol = p[1]),
          matrix(rnorm(p[2] * K * (n_cases + n_ctrl), 0, 2), ncol = p[2]))

# coefficients
beta <- as.matrix(c(rnorm(m_nz[1], 0, 0.8),
                    rep(0, p[1] - m_nz[1]),
                    rnorm(m_nz[2], 0.1, 0.4),
                    rep(0, p[2] - m_nz[2])), ncol = 1)

beta_stratum <- rep(rnorm(K, 0, 2), each= n_cases+n_ctrl)

# stratum membership
stratum <- rep(1:K, each= n_cases+n_ctrl)

# linear predictor
lin_pred <- beta_stratum + X %*% beta

prob_case <- exp(lin_pred) / (1 + exp(lin_pred))


# generate the response

Y <- rep(0, length(stratum))

data_sim <- as_tibble(data.frame(stratum = stratum, probability = prob_case,
                                 obs_id = 1 : length(stratum)))
data_sim_cases <- data_sim %>%
  group_by(stratum)%>%
  sample_n(n_cases, weight = probability)

Y[data_sim_cases$obs_id] <- 1
```

### Penalized conditional logistic regression model: variable selection

The function "penalizedclr" is used to fit a penalized conditional logistic regression model with different penalties for different blocks of covariates. The penalty parameter are used to include a L1 penalty term in the model and can be specified by the user, or computed internally. This is done by cross-validation of each data layer separately to estimate the optimal value of L1 penalty. A different mixing parameter can be specified for elastic-net penalties.


#### Case 1: Penalty parameters provided by the user

Penalty parameters can be specified for each source of covariates. This code illustrate how to fit penalized.clr with penalty parameters specified by the user. Here $\mathbf{Y}$ is the response vector, $\mathbf{X}$ is the multi-source matrix of covariates, $stratum$ is the vector of ids of the matching pairs (or sets), and $p$ is the vector of block dimensions. This has to have the same dimensions as the vector of penalty parameters $\lambda$. It is possible to standardize the variables by setting standardize = TRUE in the function (FALSE by default option).

```{r results = 'hide'}
fit1 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      lambda = c(6,7), p = p, standardize = TRUE)

```
fit1$penalized contains the regression coefficients for the penalized covariates.  We can compare these to the simulated coefficients: 

```{r}
nonzero_index <- (beta != 0) * 1
table(fitted = (fit1$penalized != 0) * 1, nonzero_index)
```



#### Case 2: Penalty parameters computed internally

When the user does not specify the penalty parameters, they are computed from a sequence of values for L1 penalty for each data source and then optimized via cross-validation. 

```{r  results = 'hide'}
fit2 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      p = p,
                      standardize = TRUE)

```

The selected penalty coefficients are: 

```{r}
fit2$lambda
```
We recommend to inspect manually the obtained $\lambda$ parameters, for example to avoid too high $\lambda$s that would result into too low selection probabilities, and to keep the proportion of relevant covariates across the different sources. Note that different runs of cross-validation will return different values of $\lambda$s.





#### Case 3: Blocks not provided

This code implements penalizedclr when no information is given about the blocks of predictors (p). Only one penalty parameter will be calculated and used to perform variable selection. 

```{r  results = 'hide'}
fit3 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      standardize = TRUE)
```

The selected penalty coefficient is: 

```{r}
fit3$lambda
```






#### Case 4: One block of covariates not penalized

This code implements penalizedclr by penalized only parts of the covariates (the first block here), and leaving the remaining block unpenalized. 

```{r  results = 'hide'}
X1 <- X[, 1:p[1]]
X2 <- X[, (p[1]+1):(p[1]+p[2])]
fit4 <- penalized.clr(response = Y, penalized = X1, unpenalized = X2, 
                      stratum = stratum, p = p[1], 
                      standardize = TRUE)
```

This can be particularly useful when performing variable selection on omics variables (penalized) and fitting the  regression model including additional clinical covariates (not penalized).

#### Case 5: Changing the L1 penalty

The package penalizedclr allows for different penalties than the lasso (L1). This is useful in presence of highly correlated covariates. L2 and L1 penalties can be combined in an elastic net framework by specifying a different value for the mixing parameter $\alpha$ in the function. 

```{r  results = 'hide'}
fit2 <- penalized.clr(response = Y, penalized = X, stratum = stratum,
                      p = p,
                      standardize = TRUE, alpha = 0.6)
```


### Penalized conditional logistic regression model: stability selection

The function "stable.clr" performs stability selection for variable selection via penalized conditional logistic regression. For each combination of penalty parameters, $2B$ subsamples of  $\lfloor n/2 \rfloor$ matched pairs are taken and a penalized model is estimated. $B$ is set to 100 by default, but can be changed by the user. Note that this choice will have an impact on the computation time, and higher values of $B$ will lead to a slower computation.  The function returns a list containing the selection probabilities of each covariate, i. e. the proportion of estimated models in which the associated coefficient estimate is different from zero. 

#### Case 1: penalty parameters given by user



```{r}
stable1 <- stable.clr(response = Y,
                      penalized = X, stratum = stratum,
                      lambda.seq = c(10,20))
```
Covariates with selection probability higher than 0.6:

```{r}
which(stable1$P>0.6)

```



#### Case 2: penalty parameters computed externally

It is possible to compute the penalty parameters via the function "find.default.lambda". It performs cross-validation to determine a sequence of $\lambda$s for L1 (or elastic-net, depending on the specified value for $\alpha$) penalties. The number of folds is set to 10 by default but can also be specified by the user.

```{r}
lambda.seq <- find.default.lambda(response = Y, 
                                  stratum = stratum, 
                                  penalized = X, 
                                  alpha=1,
                                  nfolds = 10)

lambda.seq
```

```{r}
stable2 <- stable.clr(response = Y,
                      penalized = X, stratum = stratum,
                      lambda.seq = lambda.seq)
```

Covariates with selection probability higher than 0.6:

```{r}
which(stable2$P>0.6)

```

#### Case 3: penalty parameters computed internally

If we do not specify how to compute the penalty parameters as in case 2, "stable.clr" will compute them by default by using "find.default.lambda" with default options. We only need to run: 

```{r}
stable3 <- stable.clr(response = Y,
                      penalized = X, 
                      stratum = stratum)
```

The selected $\lambda$s are: 

```{r}
stable3$lambda.seq
```


Covariates with selection probability higher than 0.6:

```{r}
which(stable3$P>0.6)

```



#### Case 4: covariates divided into blocks

This code implements stability selection for variable selection via penalized conditional logistic regression taking into account the block separation among variables ($p$). We compute the different $\lambda$s externally via "find.default.lambda" and then run "stable.clr.g". This function is an extension of "stable.clr" that allows for diffferent groups (blocks) of covariates.

```{r}

lambda.list <- find.default.lambda(response = Y,
                    penalized = X, stratum = stratum,
                    p = p)

lambda.list
```


```{r}
stable.g1 <- stable.clr.g(response = Y,
                          penalized = X,
                          stratum = stratum,
                          p = p,
                          lambda.list = lambda.list)
```


```{r}

which(stable.g1$P>0.6)
```

